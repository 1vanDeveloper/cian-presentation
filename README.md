# Integro. Автоматизация процессов в ЦИАН

## 1. Введение

Автоматизация в ЦИАН началась через 14 лет после основания компании. На тот момент был огромный монолит из Python, C# и PHP, развернутый на Linux/Windows серверах. Для деплоя этого монстра был набор скриптов, который запускали вручную. Была еще сборка монолита, приносящая боль и страдания из-за конфликтов при слиянии веток. Упрощенно процесс выглядел так:

![Процесс сборки системы на скриптах](https://habrastorage.org/r/w1560/webt/bz/tn/ll/bztnllnatyoaiauwlw0xvvaatde.jpeg)

Это не устраивало, и ребята хотели построить повторяемый, автоматизированный и управляемый процесс сборки и деплоя. Для этого была нужна CI/CD система, и ЦИАН выбирали между бесплатной версией Teamcity и бесплатной Jenkins, так как мы с ними работали и обе устраивали по набору функций. Выбрали Teamcity как более свежий продукт. Тогда еще не использовали микросервисную архитектуру и не рассчитывали на большое количество задач и проектов.

![Jenkins Vs Teamcity](https://geekflare.com/wp-content/uploads/2021/05/jenkins-teamcity.jpg)

Но в итоге после нескольких релизов системы стало более рационально использовать Jenkins, т.к. при увеличении числа собираемых репозиториев в развивающейся микросервисоной архитектуре бесплатной лицензии Teamcity стало не хватать.

![Процесс сборки системы на TeamCity](https://habrastorage.org/r/w1560/webt/hb/gv/rp/hbgvrp2ms-wfixyw-v0wycqjphy.png)

С ростом базовой автоматизации (в виде автоматического создания Pull Request-ов, сбора и публикации Code coverage и иных проверок) появилось желание максимально отказаться от ручных релизов и отдать эту работу роботам. Помимо этого внутри компании начался переезд на микросервисы, которые требовали частых релизов, причем отдельно друг от друга. Постепенно пришли к автоматическим релизам микросервисов (монолит пока что выпускаем вручную из-за сложности процесса). Но, как это обычно бывает, возникла новая сложность - потеря качества.

## Автоматизация тестирования

Из-за автоматизации релизов ускорились процессы разработки, причем частично за счет пропуска некоторых этапов тестирования. А это привело к временной потере качества.

![Дефекты в Production](https://habrastorage.org/r/w1560/webt/kk/rc/v8/kkrcv8melsazessicjkebzle2s4.jpeg)

 Нужно было задуматься об автоматизации тестирования, привитии персональной ответственности (тут речь про «принятие идеи в голове», а не денежные штрафы) разработчика за выпускаемый код и баги в нем, а также о решении по выпуску/не выпуску задачи через автоматический деплой.

 На данный момент требование к покрытию тестами добавляемого функционала не менее 80%. Для автоматизированного тестирования используются:

- unit-тесты (XUnit),
- api-тесты (Python, Docker),
- функциональные тесты (Python, Docker).

Устраняя проблемы с качеством, пришли к двум важным решениям:

- стали проводить канареечное тестирование, что позволило находить очевидные ошибки до полноценного попадания кода в production;
- внедрили автоматический мониторинг фона ошибок с автоматическим реагированием на его превышение, что уменьшило время реагирования на проблемы в production.

## Автоматизация разработки, проверки и доставки кода

Все системы, задействованные в автоматизации, можно разделить на несколько слоев:

1. Внешние системы (Jira, Bitbucket и др.). С ними работают команды разработки.
1. Платформа Integro. Чаще всего разработчики не работают с ней напрямую, но именно она поддерживает работу всей автоматизации.
1. Сервисы доставки, оркестрирования и обнаружения (к примеру, Jeknins, Consul, Nomad). С их помощью мы разворачиваем код на серверах и обеспечиваем работу сервисов друг с другом.
1. Физический уровень (сервера, ОС, смежное ПО). На этом уровне работает наш код. Это может быть как физический сервер, так и виртуальный (LXC, KVM, Docker).

![Слоеный пирог автоматизации в ЦИАН](https://habrastorage.org/r/w1560/webt/v8/xt/rz/v8xtrzfhj8bp-kzio9qduuixgf4.png)

Исходя из этой концепции мы делим зоны ответственности внутри команды DI. Два первых уровня лежат в зоне ответственности направления разработки Integro, а два последних уровня уже в зоне ответственности DevOps.

## Integro

Технологический стек:

- CentOs 7
- Docker + Nomad + Consul + Vault
- Java 11
- Spring Boot 2.X + Spring Cloud Config
- PostgreSql 11
- RabbitMQ
- Apache Ignite
- Camunda (embedded)
- Grafana + Graphite + Prometheus + Jaeger + ELK
- Web UI: React (CSR) + MobX
- SSO: Keycloak

![Микросервисная архитектура Integro](https://habrastorage.org/r/w1560/webt/ib/mn/ne/ibmnnec5ijrxrai9mpx_tdiipri.png)

Текущая версия системы имеет микросервисную архитектуру. Каждый микросервис крутится в своем docker-контейнере, сервисы общаются между собой посредством HTTP-запросов и RabbitMQ-сообщений. Микросервисы находят друг друга через Consul и выполняют к нему запрос, проходя авторизацию через SSO (Keycloak, OAuth 2/OpenID Connect).

Сейчас у нас порядка 30 микросервисов, которые можно разбить на несколько групп:

1. Управление конфигурациями.
1. Информирование и взаимодействие с пользователями (мессенджеры, почта).
1. Работа с исходным кодом.
1. Интеграция с инструментами деплоя (jenkins, nomad, consul и т. д.).
1. Мониторинг (релизов, ошибок и т. д.).
1. Web-утилиты (UI для управления тестовыми средами, сбора статистики и т. д.).
1. Интеграция с таск-трекерами и подобными системами.
1. Управление workflow для разных задач.

## Workflow задачи

Integro автоматизирует действия, связанные с жизненным циклом задачи. Упрощенно под жизненным циклом задачи будем понимать workflow задачи в Jira. В наших процессах разработки есть несколько вариаций workflow в зависимости от проекта, типа задачи и опций, выбранных в конкретной задаче.

Рассмотрим workflow, который используем чаще всего:

![Workflow](https://habrastorage.org/r/w1560/webt/yu/va/8x/yuva8xxb7edyldadgxorqwixdtm.jpeg)

На схеме шестеренка указывает, что transition вызывается Integro автоматически, в то время как фигурка человека означает, что transition вызывается вручную человеком.

## Движение задачи

Рассмотрим основные шаги, которые выполняются при движении задачи по workflow «Тестирование на DEV + канареечные тесты»:

1. Разработчик или PM создает задачу.

2. Разработчик берет задачу в работу. После завершения переводит ее в статус IN REVIEW.

3. Jira отправляет Webhook в сторону Jira-микросервиса (отвечает за интеграцию с Jira).

4. Jira-микросервис отправляет запрос в Flow-сервис (отвечает за внутренние workflow, в которых выполняется работа) для запуска workflow.

5. Внутри Flow-сервиса:

   - Назначаются ревьюеры для задачи (Users-микросервис, который знает все о пользователях + Jira-микросервис).
   - Через Source-микросервис (знает о репозиториях и ветках, но не работает с самим кодом) осуществляется поиск репозиториев, в которых есть ветка нашей задачи (для упрощения поиска имя ветки совпадает с номером задачи в Jira). Чаще всего задача имеет лишь одну ветку в одном репозитории, это упрощает управление очередью на деплой и уменьшает связность между репозиториями.
   - Для каждой найденной ветки выполняется такая последовательность действий:

      i) Подлив master-ветки (Git-микросервис для работы с кодом).

      ii) Ветка блокируется от изменений разработчиком (Bitbucket-микросервис).

      iii) Создается Pull Request на эту ветку (Bitbucket-микросервис).

      iv) Производится проверка кода: требования к оформлению кода, текущие версии библиотек, сопоставляются API всех взаимосвязанных сервисов (REST API и структура сообщений для MQ).

      v) Запускаются сборка, тестирование и деплой задачи на DEV (Jenkins-микросервис для работы с Jenkins).

      vi) Если все предыдущие пункты завершились успешно, то Integro ставит свой Approve в Pull Request (Bitbucket-микросервис).

      vii) Отправляются сообщения о новом Pull Request в чаты разработчиков-ревьюверов и автора (Notify-микросервис для работы с оповещениями).

   - Integro ожидает Approve в Pull Request от назначенных ревьюеров.
   - Как только получены все необходимые Approve (в т. ч. положительно пройдены автоматизированные тесты), Integro переводит задачу в статус Test on Dev (Jira-микросервис).

   `TODO: нужна схема`

6. Тестировщики проводят тестирование задачи. Если проблем нет, то переводят задачу в статус Ready For Build.

7. Integro «видит», что задача готова к релизу, и запускает ее деплой в канареечном режиме (Jenkins-микросервис). Готовность к релизу определяется набором правил. Например, задача в нужном статусе, нет блокировок на другие задачи, сейчас нет активных выкладок этого микросервиса и т. п.

8. Задача переводится в статус Canary (Jira-микросервис).

9. Jenkins запускает через Nomad деплой задачи в канареечном режиме (обычно 1-3 инстанса) и уведомляет о выкладке сервис мониторинга релизов (DeployWatch-микросервис).

10. DeployWatch-микросервис собирает фон ошибок и реагирует на него, если нужно. При превышении фона ошибок (норма фона рассчитывается автоматически) производится уведомление разработчиков через Notify-микросервис. Если через 5 минут разработчик не отреагировал (нажал Revert или Stay), то запускается автоматический откат канареечных инстансов. Если фон не превышен, то разработчик должен вручную запустить деплой задачи на Production (нажатием кнопки в UI). Если в течение 60 минут разработчик не запустил деплой в Production, то канареечные инстансы также в целях безопасности будут откачены.

11. После запуска деплоя на Production:

    - Задача переводится в статус Production (Jira-микросервис).

    - Jenkins-микросервис запускает процесс деплоя и уведомляет о выкладке DeployWatch-микросервис.

    - DeployWatch-микросервис проверяет, что на Production обновились все контейнеры (были случаи, когда обновлялось не все).

    - Через Notify-микросервис отправляется оповещение о результатах деплоя в Production.

    `TODO: нужна схема`

12. У разработчиков будет 30 минут на запуск отката задачи с Production в случае обнаружения некорректного поведения микросервиса. По истечении этого времени задача будет автоматически влита в master (Git-микросервис).

13. После успешного merge-а в master статус задачи будет изменен на Closed (Jira-микросервис).

Схема не претендует на полную детализацию (в реальности шагов еще больше), но позволяет оценить степень интеграции в процессы. Мы не считаем эту схему идеальной и улучшаем процессы автоматического сопровождения релизов и деплоя.

## Что дальше

Полным ходом идет развитие автоматизации, например:

- отказ от ручных операций при релизах монолита,
- улучшение мониторинга при автоматическом деплое,
- улучшение взаимодействия с разработчиками.
